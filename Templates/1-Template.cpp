#include <iostream>

template <typename T>
T Max(T a, T b)
{
    std::cout << typeid(T).name() << std::endl;
    return a > b ? a : b;
}
// Exiplict Instantiations
template char Max(char a, char b);

int main(int argc, const char **argv)
{
    // if the function template is not invoked, then the function is not generated by the compiler
    // the compiler will generate the function for only those types which it is invoked
    // The process by which the function is generated is called as instantiation.
    // The compiler will examine the arguments of the function template and it'll accordingly,deduce the type of T,
    // once the type of T is deduced,the function is instantiated for that particular type.
    auto n1 = Max(10, 20);          // <Max<int>(int, int)>
    auto n2 = Max(10.15f, 200.56f); //<Max<float>(float, float)>
    // auto n3 = Max(10, 20.5f);  // no matching function for call to ‘Max(int, float)’
    auto n3 = Max(static_cast<float>(10), 20.5f);
    auto n4 = Max<double>(10, 20.5);

    int (*fptr)(int x, int y) = Max;
    fptr(20, 40);

    /*
    instantiation happens implicitly in the following cases.
    1- when a function template is invoked.
    2- if you take the address of a function template, then the compiler is forced to instantiate
    3- explicitly instantiate a function template.
    4- explicit specialization for a function template.
    */

    return 0;
}